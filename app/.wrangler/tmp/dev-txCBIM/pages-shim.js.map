{
  "version": 3,
  "sources": ["../bundle-JmKfJy/checked-fetch.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../../../node_modules/wrangler/templates/pages-shim.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-JmKfJy/middleware-insertion-facade.js", "../bundle-JmKfJy/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/coultonfraser/Code/fraser-ever-after/app/.wrangler/tmp/dev-txCBIM",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n  const url =\n    request instanceof URL\n      ? request\n      : new URL((typeof request === 'string' ? new Request(request, init) : request).url);\n  if (url.port && url.port !== '443' && url.protocol === 'https:') {\n    if (!urls.has(url.toString())) {\n      urls.add(url.toString());\n      console.warn(\n        `WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n          ` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`,\n      );\n    }\n  }\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n  apply(target, thisArg, argArray) {\n    const [request, init] = argArray;\n    checkURL(request, init);\n    return Reflect.apply(target, thisArg, argArray);\n  },\n});\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This Worker is used as a default when no Pages Functions are present.\n// It proxies the request directly on to the asset server binding.\n\nexport default <ExportedHandler<{ ASSETS: Fetcher }>>{\n\tasync fetch(request, env, context) {\n\t\tconst response = await env.ASSETS.fetch(request.url, request);\n\t\treturn new Response(response.body, response);\n\t},\n};\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\nexport const wrap = undefined;\n", "import worker, * as OTHER_EXPORTS from '/Users/coultonfraser/Code/fraser-ever-after/app/node_modules/wrangler/templates/pages-shim.ts';\nimport * as __MIDDLEWARE_0__ from '/Users/coultonfraser/Code/fraser-ever-after/app/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts';\nconst envWrappers = [__MIDDLEWARE_0__.wrap].filter(Boolean);\nconst facade = {\n  ...worker,\n  envWrappers,\n  middleware: [__MIDDLEWARE_0__.default, ...(worker.middleware ? worker.middleware : [])].filter(Boolean),\n};\nexport * from '/Users/coultonfraser/Code/fraser-ever-after/app/node_modules/wrangler/templates/pages-shim.ts';\n\nconst maskDurableObjectDefinition = cls =>\n  class extends cls {\n    constructor(state, env) {\n      let wrappedEnv = env;\n      for (const wrapFn of envWrappers) {\n        wrappedEnv = wrapFn(wrappedEnv);\n      }\n      super(state, wrappedEnv);\n    }\n  };\n\nexport default facade;\n", "// // This loads all middlewares exposed on the middleware object\n// // and then starts the invocation chain.\n// // The big idea is that we can add these to the middleware export dynamically\n// // through wrangler, or we can potentially let users directly add them as a sort\n// // of \"plugin\" system.\n\nimport {\n  Dispatcher,\n  Middleware,\n  __facade_invoke__,\n  __facade_register__,\n} from '/Users/coultonfraser/Code/fraser-ever-after/app/node_modules/wrangler/templates/middleware/common.ts';\n\nimport worker from '/Users/coultonfraser/Code/fraser-ever-after/app/.wrangler/tmp/bundle-JmKfJy/middleware-insertion-facade.js';\n\n// We need to preserve all of the exports from the worker\nexport * from '/Users/coultonfraser/Code/fraser-ever-after/app/.wrangler/tmp/bundle-JmKfJy/middleware-insertion-facade.js';\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n  #noRetry: ScheduledController['noRetry'];\n\n  constructor(\n    readonly scheduledTime: number,\n    readonly cron: string,\n    noRetry: ScheduledController['noRetry'],\n  ) {\n    this.#noRetry = noRetry;\n  }\n\n  noRetry() {\n    if (!(this instanceof __Facade_ScheduledController__)) {\n      throw new TypeError('Illegal invocation');\n    }\n    // Need to call native method immediately in case uncaught error thrown\n    this.#noRetry();\n  }\n}\n\nconst __facade_modules_fetch__: ExportedHandlerFetchHandler = function (request, env, ctx) {\n  if (worker.fetch === undefined) throw new Error('Handler does not export a fetch() function.');\n  return worker.fetch(request, env, ctx);\n};\n\nfunction getMaskedEnv(rawEnv: unknown) {\n  let env = rawEnv as Record<string, unknown>;\n  if (worker.envWrappers && worker.envWrappers.length > 0) {\n    for (const wrapFn of worker.envWrappers) {\n      env = wrapFn(env);\n    }\n  }\n  return env;\n}\n\n/**\n * This type is here to cause a type error if a new export handler is added to\n * `ExportHandler` without it being included in the `facade` below.\n */\ntype MissingExportHandlers = Omit<\n  Required<ExportedHandler>,\n  'tail' | 'trace' | 'scheduled' | 'queue' | 'test' | 'email' | 'fetch'\n>;\n\nlet registeredMiddleware = false;\n\nconst facade: ExportedHandler<unknown> & MissingExportHandlers = {\n  ...(worker.tail && {\n    tail: maskHandlerEnv(worker.tail),\n  }),\n  ...(worker.trace && {\n    trace: maskHandlerEnv(worker.trace),\n  }),\n  ...(worker.scheduled && {\n    scheduled: maskHandlerEnv(worker.scheduled),\n  }),\n  ...(worker.queue && {\n    queue: maskHandlerEnv(worker.queue),\n  }),\n  ...(worker.test && {\n    test: maskHandlerEnv(worker.test),\n  }),\n  ...(worker.email && {\n    email: maskHandlerEnv(worker.email),\n  }),\n\n  fetch(request, rawEnv, ctx) {\n    const env = getMaskedEnv(rawEnv);\n    // Get the chain of middleware from the worker object\n    if (worker.middleware && worker.middleware.length > 0) {\n      // Make sure we only register middleware once:\n      // https://github.com/cloudflare/workers-sdk/issues/2386#issuecomment-1614715911\n      if (!registeredMiddleware) {\n        registeredMiddleware = true;\n        for (const middleware of worker.middleware) {\n          __facade_register__(middleware);\n        }\n      }\n\n      const __facade_modules_dispatch__: Dispatcher = function (type, init) {\n        if (type === 'scheduled' && worker.scheduled !== undefined) {\n          const controller = new __Facade_ScheduledController__(Date.now(), init.cron ?? '', () => {});\n          return worker.scheduled(controller, env, ctx);\n        }\n      };\n\n      return __facade_invoke__(request, env, ctx, __facade_modules_dispatch__, __facade_modules_fetch__);\n    } else {\n      // We didn't have any middleware so we can skip the invocation chain,\n      // and just call the fetch handler directly\n\n      // We \"don't care\" if this is undefined as we want to have the same behavior\n      // as if the worker completely bypassed middleware.\n      return __facade_modules_fetch__(request, env, ctx);\n    }\n  },\n};\n\ntype HandlerFn<D, R> = (data: D, env: unknown, ctx: ExecutionContext) => R;\nfunction maskHandlerEnv<D, R>(handler: HandlerFn<D, R>): HandlerFn<D, R> {\n  return (data, env, ctx) => handler(data, getMaskedEnv(env), ctx);\n}\n\nexport default facade;\n"],
  "mappings": "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",
  "names": ["facade"]
}
